#!/bin/bash

set -e

source "$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"/.init.sh

###
# Converts a directory consisting of a properties file and a resource file into
#   a `task.sh` script.
#
# Parameters:
#   {string} INPUT        The JSON file to cleanup
#   {string} PRODUCT_NAME The name of the product whose JSON is being cleaned up
##

dependency $JQ_CMD

## Variables

PIPELINES_RESOURCE=${PIPELINES_RESOURCE:-pipelines-repo}

PROPERTIES_FILE="$1"
RESOURCES_FILE="$2"
PRODUCT_NAME="$3"

COMMON_VARIABLES=("OPS_MGR_HOST" "OPS_MGR_USR" "OPS_MGR_PWD" "NETWORK_NAME" "OTHER_AZS" "SINGLETON_JOBS_AZ" "PRODUCT_NAME")

val='"$\( .key | split(".") | join("_") | sub("-"; "_") | ltrimstr("_") )"'
CONVERT_SCRIPT="
to_entries |
map(
    if (.value.value | type) == \"object\"
    then . + {\"value\": {\"value\": {\"secret\": $val}}}
    else . + {\"value\": {\"value\": $val}} end
) |
from_entries
"

## Validation

if [ ! -r "$PROPERTIES_FILE" ]; then
  ERR_CODE=4 error "Provided properties file $PROPERTIES_FILE does not exist."
fi

if [ ! -r "$RESOURCES_FILE" ]; then
  ERR_CODE=4 error "Provided resources file $RESOURCES_FILE does not exist."
fi

if [ ! -d "$OUTPUT_DIR/tasks/config-$PRODUCT_NAME" ]; then
  log "Creating directory: $OUTPUT_DIR/tasks/config-$PRODUCT_NAME"
  mkdir -p "$OUTPUT_DIR/tasks/config-$PRODUCT_NAME"
fi

OUTFILE="$OUTPUT_DIR/tasks/config-$PRODUCT_NAME/task.sh"
if [ -f "$OUTFILE" ]; then
  log "Removing existing file: $OUTFILE"
  rm -f "$OUTFILE"
fi
touch "$OUTFILE"

OUTFILE_YML="$OUTPUT_DIR/tasks/config-$PRODUCT_NAME/task.yml"
if [ -f "$OUTFILE_YML" ]; then
  log "Removing existing file: $OUTFILE_YML"
  rm -f "$OUTFILE_YML"
fi
touch "$OUTFILE_YML"

## Main

# SH File

log "Writing shabang line"
echo -e "#!/bin/bash\n" >> "$OUTFILE"

# YAML File

log "Writing image_resource"
echo "---" >> "$OUTFILE_YML"
echo -e '\n' >> "$OUTFILE_YML"
echo "platform: linux" >> "$OUTFILE_YML"
echo -e '\n' >> "$OUTFILE_YML"
echo "image_resource:" >> "$OUTFILE_YML"
echo "  type: docker-image" >> "$OUTFILE_YML"
echo "  source: {repository: rjain/buildbox}" >> "$OUTFILE_YML"
echo -e '\n' >> "$OUTFILE_YML"
echo "params:" >> "$OUTFILE_YML"

log "Writing common variables"
for variable in ${COMMON_VARIABLES[@]}; do
  echo "  $variable:" >> "$OUTFILE_YML"
done

## Properties

log "Writing properties_config"
echo 'properties_config=$(jq -n \' >> "$OUTFILE"

ARGS=
KEYS=$(cat "$PROPERTIES_FILE" | jq -r 'keys[] | split(".") | join("_") | sub("-"; "_") | ltrimstr("_")')
JSON=$(cat "$PROPERTIES_FILE" | $JQ_CMD "$CONVERT_SCRIPT" | sed 's/\"\(\$.*\)\"/\1/g')

for key in $KEYS; do
  echo "  --arg $key \$$(echo $key | awk '{print toupper($0)}') \\" >> "$OUTFILE"
  echo "  $(echo $key | awk '{print toupper($0)}'):" >> "$OUTFILE_YML"
done

echo "'$JSON'" >> "$OUTFILE"

echo -e ')\n' >> "$OUTFILE"

echo -e '\n' >> "$OUTFILE_YML"
echo "inputs:" >> "$OUTFILE_YML"
echo "  - name: $PIPELINES_RESOURCE" >> "$OUTFILE_YML"
echo "  - name: om-cli" >> "$OUTFILE_YML"
echo "  - name: $JQ_CMD" >> "$OUTFILE_YML"
echo -e '\n' >> "$OUTFILE_YML"
echo "run:" >> "$OUTFILE_YML"
echo "  path: $PIPELINES_RESOURCE/tasks/config-$PRODUCT_NAME/task.sh" >> "$OUTFILE_YML"

## Resources

log "Writing resources_config"
echo 'resources_config="{' >> "$OUTFILE"

KEYS=$(cat "$RESOURCES_FILE" | $JQ_CMD -r '.resources | .[] | .identifier' )
j=$(cat $RESOURCES_FILE | $JQ_CMD '.resources | length')

i=1
for key in $KEYS; do
  echo -n "  \\\"$key\\\": {\\\"instances\\\": \$$(echo $key | sed 's/-/_/g' | awk '{print toupper($0)}')_INSTANCES}" >> "$OUTFILE"

  if [ $((i)) -ne $((j)) ]; then
      echo -n "," >> "$OUTFILE"
  fi

  i=$((i+1))

  echo >> "$OUTFILE"
done
unset i j

echo -e '}"\n' >> "$OUTFILE"

## Network

log "Writing network_config"
echo 'network_config=$(jq -n \' >> "$OUTFILE"
echo '  --arg network_name "$NETWORK_NAME" \ ' >> "$OUTFILE"
echo '  --arg other_azs "$OTHER_AZS" \ ' >> "$OUTFILE"
echo '  --arg singleton_az "$SINGLETON_JOBS_AZ" \ ' >> "$OUTFILE"
echo '  --arg services_network_name "$SERVICES_NETWORK_NAME" \ ' >> "$OUTFILE"
echo "'" >> "$OUTFILE"
echo '  {' >> "$OUTFILE"
echo '    "network": {' >> "$OUTFILE"
echo '      "name": $network_name' >> "$OUTFILE"
echo '    },' >> "$OUTFILE"
echo '    "other_availability_zones": ($other_azs | split(",") | map({name: .})),' >> "$OUTFILE"
echo '    "singleton_availability_zone": {' >> "$OUTFILE"
echo '      "name": $singleton_az' >> "$OUTFILE"
echo '    },' >> "$OUTFILE"
echo '    "service_network": {' >> "$OUTFILE"
echo '      "name": $services_network_name' >> "$OUTFILE"
echo '    }' >> "$OUTFILE"
echo '  }' >> "$OUTFILE"
echo "'" >> "$OUTFILE"
echo -e ')\n' >> "$OUTFILE"

## Run

log "Writing om-linux command"
echo 'om-linux \' >> "$OUTFILE"
echo '  --target https://$OPSMAN_DOMAIN_OR_IP_ADDRESS \' >> "$OUTFILE"
echo '  --username "$OPS_MGR_USR" \' >> "$OUTFILE"
echo '  --password "$OPS_MGR_PWD" \' >> "$OUTFILE"
echo '  --skip-ssl-validation \' >> "$OUTFILE"
echo '  configure-product \' >> "$OUTFILE"
echo "  --product-name $PRODUCT_NAME \\" >> "$OUTFILE"
echo '  --product-properties "$properties_config" \' >> "$OUTFILE"
echo '  --product-network "$network_config" \' >> "$OUTFILE"
echo '  --product-resources "$resources_config"' >> "$OUTFILE"

echo "Wrote output to $( dirname "$OUTFILE" )"

## Cleanup

unset OUTFILE OUTFILE_YML PRODUCT_NAME CONVERT_SCRIPT COMMON_VARIABLES
